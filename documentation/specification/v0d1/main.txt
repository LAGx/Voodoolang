

набросок спецификации Voodoolang v0.1

**Цели и применение**

Цель создания языка в том, чтобы создать максимально простой и прозрачный в
использовании язык. Встраиваемый язык с отдельной стандартной библилтекой.
Он должен хорошо подходить в качестве скриптового рантайм языка для игр и
систем симуляций. Язык должен иметь максимально простой си-подобный синтаксис.

Core библиотека языка может только выполнять набор функций по заданным правилам
и имеет несколько системных функций для связки интерпритатора
с пользовательскими функциями и структурами.

Стандартная библиотека имеет стандартные типы данных (Int, Float, String),
массивы, и некоторые функции. ее нужно подключать отдельной библиотекой
и связывать с интерпритатором.


**Концепция компиляции в рантайме**

Для пользователя использование языка похоже на интерпритируемый.
На самом деле перед выполнением кода он валидируется и компилируется
в рантайме в специальные внутренние структуры (машинный код и
мета-информацию для работы с кусками машинного кода)
 для более быстрого выполнения кода. после "компиляции" код выполняется.
 Весь код условно делится на "сегменты".

 сегмент это одно или несколько "statement"(команда или заявление), т.е. выражкние, которое ничего не возвращает.
 Эта команда должна быть завершенной.

 "
 struct Person{
  Int age;
 "
  - не сегмент

  "
  struct Person{
  Int age;
  String name;
 };
"
 - сегмент

 "
 namespace core_engine{
  Int a;
"
- не сегмент

 "
 namespace core_engine{
  Int a;

  void printHello() {
    print("hello") ;
   }

   printHello() ;
 } ;
"
- сегмент


компилироватся и исполнятся код может только посегментно.
Код условно сегментируется только при вводе в компилятор,
после компиляции он сливается в общую среду и далее происходит
выполнение выполняемых выражений.

примечание (нужно это обойти)

"
printHello() ;

  void printHello() {
    print("hello") ;
  }

 "
 спровоцирует ошибку компиляции, так как printHello ещё не существует.

 При ошибке компиляции сегмент игнорируется. Даже команды, типы и функции, которые могут быть скомпилированы не сливаются в общую среду.

 ** Типизация **

 Voodoo имеет статическую, строгую типизацию.

 ** Препроцессорные шаблоны **


 struct Pearson<T>{
  String name;
  T age;
}

SOME_TYPE_NAME hello<SOME_TYPE_NAME>(SOME_TYPE_NAME) {
   return (SOME_TYPE_NAME) 78;
}



hello<int>(45);


такие декларации валидируются и сохраняются в памяти кодом.
Когда вызывается шаблонная функция или строится шаблонная структура,
имя типа просто подставляется в декларацию и компилируется в общую среду.


 ** Создание переменных, области видимости, сборщик мусора. **

 переменные ссылочного типа, но они никогда не могут быть null. Переменная всегда содержит в себе объект.

 для копирования нужно использовать
 системную функцию copy (&);

 Int a = 5;
 Int b = a;
 - а и b ссылаются на 5

 Int a = 5;
 Int b = &a;

- произошло копирование 5



 ** структуры языка**

*общие концепции синтаксиса*
 *переменные*
 *struct*
 *function*
 *namespace*



 ** модификаторы типов **

*const"

 ** Идиомы **

* псевдо ооп *

с помощью namespace и земли в начале названий для обозначения приватных переменных.

namespace Pearson{

    struct Data{
        String name;
        Int age;
    }

    Data crate() {
        return Data();
    }

    void increaseAge(Data& data) {
        data.age++;
    }

};


auto kekich = Pearson::create();
Pearson::increaseAge(kekich) ;
